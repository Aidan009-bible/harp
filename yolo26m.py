# -*- coding: utf-8 -*-
"""Yolo26m.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EHK7CWIUFNWlEORZq5spbFr_aZ_4HTga
"""

try:
    from google.colab import drive
    drive.mount('/content/drive', force_remount=True)
except ImportError:
    print("Not running in Colab - skipping drive mount. Set DATASETS_ROOT etc. to local paths.")

# --- EDIT ONLY IF YOUR FOLDER IS ELSEWHERE ---
DATASETS_ROOT = "/content/drive/MyDrive/datasets"   # raw folders: HarpCombined, SaungCombined, Fifty50
NEW_YOLO_ROOT  = "/content/drive/MyDrive/yolo_dataset_26m"  # will be created
RUNS_ROOT      = "/content/drive/MyDrive/yolo_runs"         # training runs saved here

# Training defaults (tune if you have memory issues)
IMG_SZ = 960   # 1280 is nicer for thin details but may OOM on T4 for yolo26m
BATCH  = 4     # try 2 or 1 if OOM
EPOCHS = 250

print("DATASETS_ROOT:", DATASETS_ROOT)
print("NEW_YOLO_ROOT:", NEW_YOLO_ROOT)
print("RUNS_ROOT:", RUNS_ROOT)

import os, glob
root = DATASETS_ROOT
if not os.path.exists(root):
    raise SystemExit(f"Path not found: {root}. Fix DATASETS_ROOT in cell 1 and re-run.")

# Print top-level contents and a couple of samples
print("Top-level items in:", root)
print(os.listdir(root)[:50])

# quick search counts
imgs = glob.glob(os.path.join(root, "**", "*.*"), recursive=True)
imgs = [p for p in imgs if p.lower().endswith((".jpg",".jpeg",".png",".bmp",".webp"))]
xmls = glob.glob(os.path.join(root, "**", "*.xml"), recursive=True)
txts = glob.glob(os.path.join(root, "**", "*.txt"), recursive=True)

print(f"Found: images={len(imgs)}, xmls={len(xmls)}, txts={len(txts)}")
print("sample images (up to 6):", imgs[:6])
print("sample xmls (up to 3):", xmls[:3])
print("sample txts (up to 6):", txts[:6])

import os, glob, shutil, xml.etree.ElementTree as ET, re
from PIL import Image
from pathlib import Path

SRC = DATASETS_ROOT
DST = NEW_YOLO_ROOT
IMG_DST = os.path.join(DST, "images", "train")
LBL_DST = os.path.join(DST, "labels", "train")
os.makedirs(IMG_DST, exist_ok=True)
os.makedirs(LBL_DST, exist_ok=True)

def norm_label_to_id(name):
    if not name: return None
    s = str(name).strip()
    digits = ''.join(ch for ch in s if ch.isdigit())
    if digits:
        n = int(digits)
        if 1 <= n <= 16: return n-1
    m = re.search(r'(\d{1,2})', s)
    if m:
        n=int(m.group(1))
        if 1<=n<=16: return n-1
    return None

# safe unique copy: include parent folder name in filename to avoid collisions
def safe_copy_image(src):
    parent = Path(src).parent.name
    base = os.path.basename(src)
    new_name = f"{parent}__{base}"
    dst = os.path.join(IMG_DST, new_name)
    shutil.copy(src, dst)
    return dst, new_name

# 1) copy images and any existing .txt (normalize)
img_exts = (".jpg",".jpeg",".png",".bmp",".webp")
copied_images = 0
copied_labels = 0
for root, _, files in os.walk(SRC):
    for f in files:
        if f.lower().endswith(img_exts):
            src_img = os.path.join(root,f)
            dst_img, new_name = safe_copy_image(src_img)
            copied_images += 1
            # copy same-stem .txt if exists (and normalize)
            stem = os.path.splitext(f)[0]
            txt_candidate = os.path.join(root, stem + ".txt")
            if os.path.exists(txt_candidate):
                lines = [ln.strip() for ln in open(txt_candidate, encoding='utf-8') if ln.strip()]
                norm_lines=[]
                for ln in lines:
                    parts = ln.split()
                    if parts[0].isdigit():
                        cls=int(parts[0])
                        if 0 <= cls < 16:
                            norm_lines.append(' '.join(parts[:5]))
                    else:
                        cid = norm_label_to_id(parts[0])
                        if cid is None: continue
                        if len(parts)>=5:
                            norm_lines.append(f"{cid} {' '.join(parts[1:6])}")
                if norm_lines:
                    with open(os.path.join(LBL_DST, os.path.splitext(new_name)[0]+".txt"), "w", encoding='utf-8') as fo:
                        fo.write("\n".join(norm_lines))
                    copied_labels += 1

# 2) if XMLs exist, parse them and create YOLO labels (CVAT-like)
xml_files = glob.glob(os.path.join(SRC, "**", "*.xml"), recursive=True)
converted = 0
def polyline_to_bbox(points):
    pts=[]
    for pair in points.split(";"):
        if not pair.strip(): continue
        x,y = pair.split(",")
        pts.append((float(x),float(y)))
    xs=[p[0] for p in pts]; ys=[p[1] for p in pts]
    return min(xs),min(ys),max(xs),max(ys)

if xml_files:
    for xf in xml_files:
        try:
            tree = ET.parse(xf); root=tree.getroot()
        except Exception:
            continue
        for img in root.findall("image"):
            original_name = os.path.basename(img.get("name"))
            # find copied image in IMG_DST that endswith original_name
            candidates = [p for p in glob.glob(os.path.join(IMG_DST,"*")) if p.endswith(original_name)]
            if not candidates:
                candidates = [p for p in glob.glob(os.path.join(IMG_DST,"*")) if os.path.splitext(os.path.basename(p))[0].endswith(os.path.splitext(original_name)[0])]
            if not candidates: continue
            dst_img = candidates[0]
            W = float(img.get("width")) if img.get("width") else Image.open(dst_img).size[0]
            H = float(img.get("height")) if img.get("height") else Image.open(dst_img).size[1]
            label_lines=[]
            for pl in img.findall("polyline"):
                lab = (pl.get("label") or pl.get("label_name") or "").strip()
                cid = norm_label_to_id(lab)
                if cid is None: continue
                x_min,y_min,x_max,y_max = polyline_to_bbox(pl.get("points"))
                cx=(x_min+x_max)/2/W; cy=(y_min+y_max)/2/H
                w=(x_max-x_min)/W; h=(y_max-y_min)/H
                label_lines.append(f"{cid} {cx:.6f} {cy:.6f} {w:.6f} {h:.6f}")
            for box in img.findall("box"):
                lab = (box.get("label") or box.get("label_name") or "").strip()
                cid = norm_label_to_id(lab)
                if cid is None: continue
                try:
                    x_min=float(box.get("xtl")); y_min=float(box.get("ytl"))
                    x_max=float(box.get("xbr")); y_max=float(box.get("ybr"))
                except:
                    continue
                cx=(x_min+x_max)/2/W; cy=(y_min+y_max)/2/H
                w=(x_max-x_min)/W; h=(y_max-y_min)/H
                label_lines.append(f"{cid} {cx:.6f} {cy:.6f} {w:.6f} {h:.6f}")
            if label_lines:
                out_lbl = os.path.join(LBL_DST, os.path.splitext(os.path.basename(dst_img))[0]+".txt")
                with open(out_lbl, "w", encoding='utf-8') as fo: fo.write("\n".join(label_lines))
                converted += 1

print(f"Copied images: {copied_images}, copied/normalized txts: {copied_labels}, converted xmls -> {converted}")
print("Final counts in new YOLO dataset:")
print(" images:", len(glob.glob(os.path.join(IMG_DST,"*.*"))))
print(" labels:", len(glob.glob(os.path.join(LBL_DST,"*.txt"))))

data_yaml_path = os.path.join(NEW_YOLO_ROOT, "data.yaml")
with open(data_yaml_path, "w") as f:
    f.write(f"path: {NEW_YOLO_ROOT}\ntrain: images/train\nval: images/train\nnames:\n")
    for i in range(16):
        f.write(f"  {i}: S{i+1}\n")
print("Wrote:", data_yaml_path)

import random, glob
lbls = glob.glob(os.path.join(LBL_DST, "*.txt"))
imgs = glob.glob(os.path.join(IMG_DST, "*.*"))
print("labels:", len(lbls), "images:", len(imgs))
print("sample labels (3):")
for p in lbls[:3]:
    print("----", p)
    print(open(p, encoding='utf-8').read()[:400])
print("sample images (3):", imgs[:3])

# run in a single cell
import subprocess
subprocess.run(["pip", "install", "-U", "ultralytics", "--quiet"], check=True)

from ultralytics import YOLO
import os, torch

print("torch.cuda:", torch.cuda.is_available(), torch.cuda.device_count())
print("Using model yolo26m.pt (pretrained). If you want to fine-tune from a checkpoint, replace model path.")

# change imgsz/batch if OOM
model = YOLO("yolo26m.pt")

# Train: if GPU memory error, reduce imgsz to 640 and batch to 1 or 2
model.train(
    data=data_yaml_path,
    epochs=EPOCHS,
    imgsz=IMG_SZ,
    batch=BATCH,
    project=RUNS_ROOT,
    name="yolo26m_fresh",
    exist_ok=True,
    augment=True,
    auto_augment="randaugment",
    copy_paste=0.5,
    lr0=0.01,
    patience=100
)

from ultralytics import YOLO
import glob, os, random, cv2
from PIL import Image, ImageDraw, ImageFont
from IPython.display import display

# find best weights
run_name = "yolo26m_fresh"
best = glob.glob(os.path.join(RUNS_ROOT, run_name, "**", "weights", "best.pt"), recursive=True)
if not best:
    print("No best.pt found for run", run_name)
else:
    weights = best[0]
    print("Using weights:", weights)
    model = YOLO(weights)
    samples = glob.glob(os.path.join(NEW_YOLO_ROOT, "images", "train", "*.*"))
    samples = random.sample(samples, min(6, len(samples)))
    out_dir = os.path.join(RUNS_ROOT, "pred_vis", run_name)
    os.makedirs(out_dir, exist_ok=True)
    for p in samples:
        r = model.predict(source=p, imgsz=IMG_SZ, conf=0.06, save=False)[0]
        # r.orig_img is BGR (numpy) â€” convert to RGB for display
        img_rgb = cv2.cvtColor(r.orig_img, cv2.COLOR_BGR2RGB)
        im = Image.fromarray(img_rgb)
        draw = ImageDraw.Draw(im)
        try:
            font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 14)
        except:
            font = None
        if hasattr(r, "boxes"):
            for box, cls, conf in zip(r.boxes.xyxy, r.boxes.cls, r.boxes.conf):
                x1,y1,x2,y2 = [float(x) for x in box.tolist()]
                label = f"{r.names[int(cls)]} {float(conf):.2f}"
                draw.rectangle([x1,y1,x2,y2], outline=(255,255,0), width=2)
                draw.text((x1+2, y1+2), label, fill=(0,0,0), font=font)
        display(im)
        save_path = os.path.join(out_dir, os.path.basename(p))
        im.save(save_path)
        print("Saved:", save_path)